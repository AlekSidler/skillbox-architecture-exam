[Heading](../heading.md)

[Previous chapter](09-nfr.md)

[Next chapter](11-adr.md)

# Анализ и описание архитектурных опций и обоснование выбора

Мы в части про [концептуальную архитектуру](04-conceptual-architecture.md) решили, что будем сразу строить микросервисную архитектуру и постарались обосновать свой выбор.

Как известно, любой выбор имеет свои достоинства и недостатки, важно искать решения, подходящие нашим аттрибутам качества, функциональным и нефункциональным требованиям.

Рассмотрим следующие компромиссы:

## REST API vs gRPC vs Messaging

Выбор системы коммуникаций между внутренними сервисами зависит от особенностей и потребностей самих сервисов.

Особенностью Message queue является асинхронность вызова, высокая масштабируемость обработки сообщений. Но получение ответа данным способом не тривиально.
Messaging удобно использовать для оповещений, а также для событий, на которые будут подписываться один или несколько сервисов.

Особенностью REST API является синхронность выполнения. Из этого следует, что удобно обрабатывать ошибки таких запросов.
Благодаря блокирующему вызову, упрощается код из-за последовательной логики в коде.

Также можно выделить RPC. Это разновидность REST API со своими особенностями. Например, одна из реализаций, [gRPC](https://grpc.io/), имеет чуть большую производительность, но требует предварительной инициализации соединения.

Предпочёл бы использовать messaging для отправки сообщений, в которых есть один или несколько получателей и от которых мы не ждём ответа. То есть данный способ отлично подойдёт для следующих случаев:
* Отправка уведомлений пользователям
* Обработка данных фитнес браслета
* Обработка данных тренировки и отчёта о тренировке

REST или gRPC считаю взаимозаменяемыми и выбор по их использованию должен приходиться на сами команды. Но высоконагруженное межсервисное общение должно происходить через gRPC.


При разработке сервисов, общающихся с сервисами другой команды важно перед началом работы договориться об используемых и предоставляемых интерфейсах, тут следует первым делом зафиксировать API и использовать для фиксации:
* REST: Swagger
* Messaging: AsyncAPI
* gRPC: Swagger или proto файлы

## Облако vs свои сервера

Недостаток своих серверов в том, что их нужно самим настраивать и обслуживать.
Для этого нужны администраторы и DevOps-ы. Как вариант, возможно отдать инфраструктурную часть в outsourcing, используя, например, DevOps as a Service (DaaS) услугу. Этот вариант является достаточно гибким так как мы можем выбирать любое решение.

Как альтернативный вариант, мы можем запускать наши сервисы на облачных машинах.
Этот способ позволяет быстро развернуть и настроить машины для наших нужд. Мы также можем выбрать PaaS, чтобы была развёрнута платформа, на которой будут работать наши приложения. Этот вариант самый быстрый и простой, но не совсем гибкий, так как мы ограничены тем, что предлагает платформа.

Оптимальным вариантом по гибкости будут облачные машины, которые будут отданы под DaaS услугу. Тем самым мы получаем скорость разработки и различный выбор технологий.

На данный момент, 90% сервисов запускается именно на облачных машинах, а 10% на своих серверах. Планируется оставить такое соотношение. Большинство сервисов будет запущено в облаке, а базы данных с важной информацией будут запущены на своих собственных серверах. Все машины будут пользоваться DaaS услугой.


В идеале бы конечно использовать единый облачный провайдер так как не нужно писать много обвязки, провайдер наверняка может сделать хорошую скидку из-за большого количества используемых машин. Но из-за политических рисков желательно использовать несколько провайдеров. Также трудно найти провайдера, у которого будут сервера во всех странах. Но их количество желательно сократить, но без вреда функционалу/стоимости.

Вне зависимости от решения, приложения должны относиться к инфраструктуре, как к сервису и должны следовать Twelve-Factor App для упрощённой замены инфраструктурной части в будущем.
